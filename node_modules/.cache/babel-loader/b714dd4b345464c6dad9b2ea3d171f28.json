{"ast":null,"code":"import { Response } from \"miragejs\";\nimport { requiresAuth } from \"../utils/authUtils\";\nimport { v4 as uuid } from \"uuid\";\n/**\n * All the routes related to Notes are present here.\n *  These are Privately accessible routes.\n * */\n\n/**\n * This handler handles gets all notes in the db.\n * send GET Request at /api/notes\n * */\n\nexport const getAllNotesHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n\n  if (!user) {\n    return new Response(404, {}, {\n      errors: [\"The email you entered is not Registered. Not Found error\"]\n    });\n  }\n\n  return new Response(200, {}, {\n    notes: user.notes\n  });\n};\n/**\n * This handler handles creating a new note\n * send POST Request at /api/notes\n * body contains {note}\n * */\n\nexport const createNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n\n  try {\n    if (!user) {\n      return new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n\n    const {\n      note\n    } = JSON.parse(request.requestBody);\n\n    if (!note.tags) {\n      user.notes.push({ ...note,\n        _id: uuid(),\n        tags: []\n      });\n    } else {\n      user.notes.push({ ...note,\n        _id: uuid()\n      });\n    }\n\n    this.db.users.update({\n      _id: user._id\n    }, user);\n    return new Response(201, {}, {\n      notes: user.notes\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};\n/**\n * This handler handles creating a new note\n * send DELETE Request at /api/notes/:noteId\n * */\n\nexport const deleteNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n\n  try {\n    if (!user) {\n      return new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n\n    const noteId = request.params.noteId;\n    user.notes = user.notes.filter(item => item._id !== noteId);\n    this.db.users.update({\n      _id: user._id\n    }, user);\n    return new Response(200, {}, {\n      notes: user.notes\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};\n/**\n * This handler handles updating a note\n * send POST Request at /api/notes/:noteId\n * body contains {note}\n * */\n\nexport const updateNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n\n  try {\n    if (!user) {\n      return new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n\n    const {\n      note\n    } = JSON.parse(request.requestBody);\n    const {\n      noteId\n    } = request.params;\n    const noteIndex = user.notes.findIndex(note => note._id === noteId);\n    user.notes[noteIndex] = { ...user.notes[noteIndex],\n      ...note\n    };\n    this.db.users.update({\n      _id: user._id\n    }, user);\n    return new Response(201, {}, {\n      notes: user.notes\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};\n/**\n * This handler handles archiving a note\n * send POST Request at /api/notes/archive/:noteId\n * body contains {note}\n * */\n\nexport const archiveNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n\n  try {\n    if (!user) {\n      return new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n\n    const {\n      noteId\n    } = request.params;\n    const archivedNote = user.notes.filter(note => note._id === noteId)[0];\n    user.notes = user.notes.filter(note => note._id !== noteId);\n    user.archives.push({ ...archivedNote\n    });\n    this.db.users.update({\n      _id: user._id\n    }, user);\n    return new Response(201, {}, {\n      archives: user.archives,\n      notes: user.notes\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};","map":{"version":3,"sources":["/Users/amiteshmanitiwari/Downloads/my-notes/src/backend/controllers/NotesController.js"],"names":["Response","requiresAuth","v4","uuid","getAllNotesHandler","schema","request","user","call","errors","notes","createNoteHandler","note","JSON","parse","requestBody","tags","push","_id","db","users","update","error","deleteNoteHandler","noteId","params","filter","item","updateNoteHandler","noteIndex","findIndex","archiveNoteHandler","archivedNote","archives"],"mappings":"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","sourcesContent":["import { Response } from \"miragejs\";\nimport { requiresAuth } from \"../utils/authUtils\";\nimport { v4 as uuid } from \"uuid\";\n\n/**\n * All the routes related to Notes are present here.\n *  These are Privately accessible routes.\n * */\n\n/**\n * This handler handles gets all notes in the db.\n * send GET Request at /api/notes\n * */\n\nexport const getAllNotesHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n  if (!user) {\n    return new Response(\n      404,\n      {},\n      {\n        errors: [\"The email you entered is not Registered. Not Found error\"],\n      }\n    );\n  }\n  return new Response(200, {}, { notes: user.notes });\n};\n\n/**\n * This handler handles creating a new note\n * send POST Request at /api/notes\n * body contains {note}\n * */\n\nexport const createNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n  try {\n    if (!user) {\n      return new Response(\n        404,\n        {},\n        {\n          errors: [\"The email you entered is not Registered. Not Found error\"],\n        }\n      );\n    }\n    const { note } = JSON.parse(request.requestBody);\n    if (!note.tags) {\n      user.notes.push({ ...note, _id: uuid(), tags: [] });\n    } else {\n      user.notes.push({ ...note, _id: uuid() });\n    }\n    this.db.users.update({ _id: user._id }, user);\n    return new Response(201, {}, { notes: user.notes });\n  } catch (error) {\n    return new Response(\n      500,\n      {},\n      {\n        error,\n      }\n    );\n  }\n};\n\n/**\n * This handler handles creating a new note\n * send DELETE Request at /api/notes/:noteId\n * */\n\nexport const deleteNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n  try {\n    if (!user) {\n      return new Response(\n        404,\n        {},\n        {\n          errors: [\"The email you entered is not Registered. Not Found error\"],\n        }\n      );\n    }\n    const noteId = request.params.noteId;\n    user.notes = user.notes.filter((item) => item._id !== noteId);\n    this.db.users.update({ _id: user._id }, user);\n    return new Response(200, {}, { notes: user.notes });\n  } catch (error) {\n    return new Response(\n      500,\n      {},\n      {\n        error,\n      }\n    );\n  }\n};\n\n/**\n * This handler handles updating a note\n * send POST Request at /api/notes/:noteId\n * body contains {note}\n * */\n\nexport const updateNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n  try {\n    if (!user) {\n      return new Response(\n        404,\n        {},\n        {\n          errors: [\"The email you entered is not Registered. Not Found error\"],\n        }\n      );\n    }\n    const { note } = JSON.parse(request.requestBody);\n    const { noteId } = request.params;\n    const noteIndex = user.notes.findIndex((note) => note._id === noteId);\n    user.notes[noteIndex] = { ...user.notes[noteIndex], ...note };\n    this.db.users.update({ _id: user._id }, user);\n    return new Response(201, {}, { notes: user.notes });\n  } catch (error) {\n    return new Response(\n      500,\n      {},\n      {\n        error,\n      }\n    );\n  }\n};\n\n/**\n * This handler handles archiving a note\n * send POST Request at /api/notes/archive/:noteId\n * body contains {note}\n * */\n\nexport const archiveNoteHandler = function (schema, request) {\n  const user = requiresAuth.call(this, request);\n  try {\n    if (!user) {\n      return new Response(\n        404,\n        {},\n        {\n          errors: [\"The email you entered is not Registered. Not Found error\"],\n        }\n      );\n    }\n    const { noteId } = request.params;\n    const archivedNote = user.notes.filter((note) => note._id === noteId)[0];\n    user.notes = user.notes.filter((note) => note._id !== noteId);\n    user.archives.push({ ...archivedNote });\n    this.db.users.update({ _id: user._id }, user);\n    return new Response(\n      201,\n      {},\n      { archives: user.archives, notes: user.notes }\n    );\n  } catch (error) {\n    return new Response(\n      500,\n      {},\n      {\n        error,\n      }\n    );\n  }\n};\n"]},"metadata":{},"sourceType":"module"}